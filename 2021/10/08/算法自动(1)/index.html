<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="熊英飞老师网址1 网址  https:&#x2F;&#x2F;xiongyingfei.github.io&#x2F;recruit2022.html  我现在重点关注一个研究问题：计算机能否自动生成算法？能做到什么程度？具体而言，给定形式化描述的算法问题，比如排序问题可以描述为：输入：i:list，输出：o:list，满足bag(o)&#x3D;bag(i) &#x2F;\ for any 0&lt;&#x3D;i&lt;j&lt;len(o), o[i">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/10/08/%E7%AE%97%E6%B3%95%E8%87%AA%E5%8A%A8(1)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="熊英飞老师网址1 网址  https:&#x2F;&#x2F;xiongyingfei.github.io&#x2F;recruit2022.html  我现在重点关注一个研究问题：计算机能否自动生成算法？能做到什么程度？具体而言，给定形式化描述的算法问题，比如排序问题可以描述为：输入：i:list，输出：o:list，满足bag(o)&#x3D;bag(i) &#x2F;\ for any 0&lt;&#x3D;i&lt;j&lt;len(o), o[i">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/TyporaImage/image-20210712155829124.png">
<meta property="og:image" content="c:/TyporaImage/image-20210712161955791.png">
<meta property="og:image" content="c:/TyporaImage/image-20210712203159247.png">
<meta property="article:published_time" content="2021-10-08T00:13:45.323Z">
<meta property="article:modified_time" content="2021-07-15T07:23:18.122Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/TyporaImage/image-20210712155829124.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-算法自动(1)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/08/%E7%AE%97%E6%B3%95%E8%87%AA%E5%8A%A8(1)/" class="article-date">
  <time class="dt-published" datetime="2021-10-08T00:13:45.323Z" itemprop="datePublished">2021-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="熊英飞老师网址"><a href="#熊英飞老师网址" class="headerlink" title="熊英飞老师网址"></a>熊英飞老师网址</h2><p>1 网址</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://xiongyingfei.github.io/recruit2022.html">https://xiongyingfei.github.io/recruit2022.html</a></p>
</blockquote>
<p>我现在重点关注一个研究问题：计算机能否自动生成算法？能做到什么程度？具体而言，给定形式化描述的算法问题，比如排序问题可以描述为：输入：i:list，输出：o:list，满足bag(o)=bag(i) /\ for any 0&lt;=i&lt;j&lt;len(o), o[i] &lt;= o[j]，我们希望能自动生成该问题的算法，效率越高越好。我们目前正在构建一个基于算法竞赛的题库，希望能找到算法自动解出尽可能多的题目。 </p>
<p>该问题有重要的研究价值和实践意义。让计算机学会自己写程序一直是科学家的美好愿望，但到目前能自动写的都是非常简单的程序，能够自动写出复杂的算法才真正学会了编程。在实践中，找到好的算法来优化程序一直是程序员面临的最大难题之一。该问题的解决方案可以辅助程序员设计算法，或者把程序看做形式化描述的问题本身，也可以自动优化写好的程序。</p>
<p>这个问题虽然较难，但不同领域的计算机科学家多年的积累已经给我们提供了解决该问题的基础。如果你也对该问题感兴趣，并且有兴趣在我的指导下攻读博士，可以先学习一下我的<a target="_blank" rel="noopener" href="https://xiongyingfei.github.io/SA/2020/main.htm">《软件分析技术》课</a>中关于程序综合的三次课的内容，并简要学习如下三项内容之一：</p>
<ul>
<li>程序演算的相关知识。推荐书《Algebra of Programming》作者Richard Bird和Oege de Moor。</li>
<li>约束编程的相关知识。推荐书《Principles of Constraint Programming》作者Krzysztof R. Apt。</li>
<li>决策过程的相关知识。推荐书《Decision Procedures: An Algorithmic Point of View》作者Daniel Kroening和Ofer Strichman。</li>
</ul>
<p>学习之后欢迎和我讨论你关于做这个问题的思路。</p>
<h2 id="软件分析技术-Software-Analysis"><a href="#软件分析技术-Software-Analysis" class="headerlink" title="软件分析技术(Software Analysis)"></a>软件分析技术(Software Analysis)</h2><p>程序分析技术关注如何做出正确的逼近,或者采用统计等概率手段来弥补.</p>
<h3 id="第一次课"><a href="#第一次课" class="headerlink" title="第一次课"></a>第一次课</h3><p>1 如何判断程序中的缺陷,比如判断c语言程序是否有内存泄漏,我们一般的做法是通过大量的实例去测试,这种枚举的方法对于测过的地方是可以保证程序没问题的,但是对于没测试过的地方,无法保证是否存在问题,也可以认为出现问题的概率也给不出来,这是不应该的.</p>
<p>2 哥德尔 , 哥德尔不完备定理; 没有bug 的程序是不存在的;</p>
<p>完备性:所有的真命题都可以被证明;</p>
<p>一致性:一个命题要么为真要么为假;</p>
<p>数学公理用素数表示,能推出来的用合数表示,那么</p>
<blockquote>
<p>计算机中的P与NP问题;</p>
</blockquote>
<p>根据哥德尔不完备性定理,编程语言是有限的,所以总有算法所不能表达.</p>
<p>3 原始方法输出是否,近似法:允许在得不到精确值的时候,给出不精确的答案,不精确的答案叫做不知道.</p>
<p>4 近似解 抽象法:</p>
<p>比如 正+负不知道是正数还是负数,就是不知道了</p>
<p>近似解:搜索法</p>
<p>遍历,超时就是不知道,有反例就是不成立,遍历完了都成立就是成立</p>
<h3 id="程序与算法"><a href="#程序与算法" class="headerlink" title="程序与算法"></a>程序与算法</h3><p>熊老师的想法是自动生成算法,</p>
<blockquote>
<p>比如排序问题可以描述为：输入：i:list，输出：o:list，满足bag(o)=bag(i) /\ for any 0&lt;=i&lt;j&lt;len(o), o[i] &lt;= o[j]，我们希望能自动生成该问题的算法，效率越高越好。</p>
</blockquote>
<p>算法的定义有几种,我在知乎上查询算法和程序有什么关系,大部分的回答都是算法是解决问题的思路,程序是具体的实现.谭sir 那本书上我记得,算法+数据结构=程序.按这个类推,解决问题的思路+队列等结构=程序.也可以理解成算法是比较固定的,我用冒泡排序的思想,可以使用队列可以使用栈,而且c语言python语言都不限制,都可以写程序.</p>
<h3 id="Code-Generation-Based-on-Deep-Learning-a-Brief-Review"><a href="#Code-Generation-Based-on-Deep-Learning-a-Brief-Review" class="headerlink" title="Code Generation Based on Deep Learning: a Brief Review"></a>Code Generation Based on Deep Learning: a Brief Review</h3><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><p>software engineering(SE)</p>
<p>deep learning(DL)</p>
<p>code completion:代码生成</p>
<blockquote>
<p><strong>Autocomplete</strong>, or <strong>word completion</strong>, is a feature in which an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_software">application</a> predicts the rest of a word a user is typing. In Android and iOS[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Autocomplete#cite_note-1">1]</a> smartphones, this is called <strong>predictive text</strong>. In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphical_user_interface">graphical user interfaces</a>, users can typically press the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tab_key">tab key</a> to accept a suggestion or the down <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Arrow_key">arrow key</a> to accept one of several.</p>
</blockquote>
<p>IDEs (integrated development environments)</p>
<p>code patches :代码补丁</p>
<p>code synthesis: 狭义的代码生成</p>
<p>LMs:language models;和代码补全生成等相关的模型</p>
<p>API: API（Application Programming Interface,[应用程序编程接口）是一些预先定义的[函数]，目的是提供[应用程序]与开发人员基于某[软件]或硬件得以访问一组[例程]的能力，而又无需访问源码，或理解内部工作[机制]的细节。</p>
<p>deductive program synthesis (DPS)</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>1 两种tool补全代码 </p>
<p>input-output samples; functionality description;</p>
<p>2 代码生成的定义</p>
<blockquote>
<p>automatic code generation refers to the utilization of tech-<br>niques to automatically generate source code for software devel-<br>opment, according to the requirements from the users. </p>
</blockquote>
<p>3 </p>
<blockquote>
<p> There are two major tasks in code generation – code completion and code<br>synthesis, which are the subjects of this paper.</p>
</blockquote>
<p>4 heuristic</p>
<blockquote>
<p>A heuristic or heuristic technique (/hjʊəˈrɪstɪk/; Ancient Greek: εὑρίσκω, heurískō, ‘I find, discover’), is any approach to problem solving or self-discovery that employs a practical method that is not guaranteed to be optimal, perfect, or rational, but is nevertheless sufficient for reaching an immediate, short-term goal or approximation. Where finding an optimal solution is impossible or impractical, heuristic methods can be used to speed up the process of finding a satisfactory solution. Heuristics can be mental shortcuts that ease the cognitive load of making a decision.[1][2] </p>
</blockquote>
<p>现实主义</p>
<p>5 Code synthesis </p>
<p>狭义的代码生成,传统的代码生成.</p>
<p>代码生成分为 基于input-output samples的代码生成, 基于functionality description 的代码生成.</p>
<p>6 研究方向</p>
<blockquote>
<p>There are at least three possible research directions in this field:</p>
<ol>
<li>to encode the context-free grammars into the neural network<br>for better syntax understanding, 2) to apply code completion for<br>specific development tool to alleviate the burden of software devel-<br>opment, and 3) to counter the adversarial non-robust issue caused<br>bythenatureofDLmodelsbyintroducingthefeaturesofprogram-<br>ming languages.</li>
</ol>
</blockquote>
<ul>
<li>将上下文无关文法编码到神经网络,为了更好理解语法.</li>
<li>应用于特定的工具</li>
<li>对抗DL模型的非健壮性,通过引入变成语言的特性(表示不理解,玄乎5)</li>
</ul>
<p>7 code completion</p>
<p><img src="C:\TyporaImage\image-20210712155829124.png" alt="image-20210712155829124"></p>
<p>$x$: ABCDEF,每一个都是$t$,即$t_1,..t_6$</p>
<p>$x_{1:k}$ :ABC</p>
<p>$f$:一个模型,一个黑盒子,经过它知道选择下一个选项的概率,还是选择某一个选项的概率呢?</p>
<p>$P_f(..)$: 条件概率,在ABC的条件下,选择x中的某一个的概率,还是选择下一项的概率呢?看这架势应该是输出一个t,或者代表t的东西,即选择下一项出现的概率.当然其实也一样,我选择EF的概率都求出来,选择一个概率最大的,也就变成了选择下一项出现的概率 这一问题.</p>
<p><img src="C:\TyporaImage\image-20210712161955791.png" alt="image-20210712161955791"></p>
<p>圈$f$ 是训练参数集合,L是loss;意思是在参数下,所有的loss相加最小,最好为0,就完美了.但是,这也算一种启发式吧.</p>
<p><img src="C:\TyporaImage\image-20210712203159247.png" alt="image-20210712203159247"></p>
<p>$z$: 用户需求</p>
<p>$g()$:model,生成code snippet;</p>
<p>$y$: 真值</p>
<p>8 一系列方法</p>
<p>code completion 特别注重局部特征;LM忽略了局部特征.e</p>
<p>关于code completion</p>
<p>non-terminal node 当作代码的结构信息.</p>
<p>确保ast变成seq时,保证ast 序列的唯一性.</p>
<p>API completion:比如 补全一个接口程序的名字,和code completion差不多,只是这个是api;</p>
<blockquote>
<p>so the similarity of vectors can be used to generate API sequences.</p>
</blockquote>
<p>相近的向量用来生成api,我感觉还是choose靠谱一点.</p>
<p>问题明显,局限于小样本,单功能程序;不通用;</p>
<p>4 code synthesis</p>
<p>4.1input-output samples</p>
<p>traditional :inductive program synthesis(IPS);归纳程序生成;programming by examples(PEB)</p>
<p>数据的来源: 1)明确定义的语言(domain specific language DSL) 2)excel data?</p>
<p>4.2 natural language descriptions</p>
<p>通过嵌入训练,把不好的自然语言描述变成好的自然语言描述.</p>
<blockquote>
<p>automatic generation of general programming language is rather difficult than IFTTT.</p>
</blockquote>
<p>5 future work</p>
<p>5.1 grammar information</p>
<p>a-&gt;b 1, b-&gt;c 2;不知道12是不是合法的,这啥意思,你到时候映射一下不就行了?</p>
<p>5.2 code generation testing</p>
<p>翻译不一致的问题,比如打开电灯翻译成open light only,打开冰箱就成了open ice ;</p>
<p>我们要修复我们的错误,通过一种”集成”的策略;emsemble;</p>
<p>5.3 application</p>
<p>5.4 adversarial robustness</p>
<p>adversarial training;对抗性训练;</p>
<p>6 related work</p>
<p>6.1 program synthesis</p>
<p>6.2 code completion</p>
<p>  建议文章,probabilistic model for code with decision tree和    Code Completion<br>with Neural Attention and Pointer Networks. </p>
<p>6.3 code retrieval 代码检索</p>
<p>给定自然描述检索最相关的代码. </p>
<p>CoaCor: Code<br>Annotation for Code Retrieval with Reinforcement Learning.这篇文章关于代码检索的</p>
<p>Retrieval-Based Neural Code Generation.这篇文章把检索和代码生成的方法结合在一起</p>
<p>7 summary</p>
<blockquote>
<p>The current code generation technology is limited to generating small-scale,<br>single-function, domain-specific programs, and its technology is<br>still very limited for complex programs.</p>
</blockquote>
<blockquote>
<p> how to better handle the excessively large vocabulary in the programming language is also an optional way to conduct research on code generation based on deep learning. </p>
</blockquote>
<p>a</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/08/%E7%AE%97%E6%B3%95%E8%87%AA%E5%8A%A8(1)/" data-id="ckuhma5ns00091ccw2299fov1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/10/08/platform%E6%A8%A1%E5%9D%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/10/08/%E5%85%B3%E4%BA%8East-code%E5%8F%8C%E5%90%91%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%B0%83%E7%A0%94/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blogging/">Blogging</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blogging/Tutorial/">Tutorial</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello/" rel="tag">hello</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hello/" style="font-size: 10px;">hello</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/08/os%E6%A8%A1%E5%9D%97/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/08/Graphviz%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/08/args%E5%92%8Ckwargs%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/10/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>